<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="33">





<title>数据结构与算法(三):线性表 | Siruili&#39;s Blog</title>



    <link rel="icon" href="/joy.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 4.2.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Siruili&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Siruili&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">数据结构与算法(三):线性表</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">33</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">April 2, 2020&nbsp;&nbsp;20:38:37</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Notes/">Notes</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><h4 id="什么是线性表"><a href="#什么是线性表" class="headerlink" title="什么是线性表"></a>什么是线性表</h4><p><strong>线性表:由零个或多个数据元素足证的有限序列.</strong></p>
<ul>
<li>首先,它是一个序列,元素之间有一个先来后到.</li>
<li><strong>若元素存在多个,则第一个元素无前驱,最后一个元素无后继,其他元素都有一个前驱和后继.</strong></li>
<li>另外,线性表强调是有限的,事实上无论计算机发展到多强大,它所处理的数据都是有限的.</li>
<li>允许有空表,线性表元素的个数n=0时,称为空表.</li>
</ul>
<h4 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><p><strong>数据类型</strong>:是指一组性质相同的值的集合及定义在此集合上的一些操作的总称.<br>例如:整型、浮点型、字符型这些指的就是数据类型.</p>
<p>例如在C语言中,按照取值的不同,数据类型可以分为两类:</p>
<ul>
<li>原子类型:不可以再分解的基本类型,例如:整形、浮点型、字符型等.</li>
<li>结构类型:由若干个类型组合而成,可以再分解,例如整型数组是由若干个整型数据组成的.</li>
<li><strong>抽象类型</strong>:是指一个数学模型及定义在该模型上的一组操作.抽象数据类型的定义仅取决于它的一组逻辑特性，与其在计算机内部如何表示和实现无关.例如我们定义一个坐标point由x、y、z三个整型数据组合,那么point就是一个抽象数据类型.</li>
</ul>
<p><strong>抽象数据类型标准格式</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ADT 抽象数据类型名</span><br><span class="line">Data</span><br><span class="line">	数据元素之间逻辑关系的定义</span><br><span class="line">Opreration</span><br><span class="line">	操作</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>

<h4 id="线性表的类型定义"><a href="#线性表的类型定义" class="headerlink" title="线性表的类型定义"></a>线性表的类型定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ADT LIST&#123;</span><br><span class="line">	数据对象：D=&#123;ai|ai属于elemset，（i=<span class="number">1</span>，<span class="number">2</span>，...n,n&gt;=<span class="number">0</span>）&#125;</span><br><span class="line">	数据关系:R =&#123;&lt;ai<span class="number">-1</span>,ai&gt;|ai<span class="number">-1</span>,ai属于D，(i=<span class="number">2</span>,<span class="number">3</span>,...,n)&#125;</span><br><span class="line">	基本操作：</span><br><span class="line">	initList(&amp;L); <span class="comment">//初始化</span></span><br><span class="line">	DestroyList(&amp;L); <span class="comment">//销毁</span></span><br><span class="line">	ListInsert(&amp;L,i,e);<span class="comment">//插入</span></span><br><span class="line">	ListDelete(&amp;L,i,&amp;e);<span class="comment">//删除</span></span><br><span class="line">	...等等</span><br><span class="line">&#125;ADT List</span><br></pre></td></tr></table></figure>

<h5 id="基本操作-一"><a href="#基本操作-一" class="headerlink" title="基本操作(一)"></a>基本操作(一)</h5><ul>
<li>InitList(&amp;L)<br>构造一个空的线性表L</li>
<li>DestroyList(&amp;L)<br>初始条件:线性表L必须存在<br>操作结果:销毁线性表L</li>
<li>ClearList(&amp;L)<br>初始条件:线性表L必须存在<br>操作结果:将线性表L重置为空表</li>
</ul>
<h5 id="基本操作-二"><a href="#基本操作-二" class="headerlink" title="基本操作(二)"></a>基本操作(二)</h5><ul>
<li>ListEmpty(L)<br>初始条件: 线性表L必须存在<br>操作结果:若线性表L为空表(n=0),则返回TURE;否则返回FALSE</li>
<li>ListLength(L)<br>初始条件:线性表L必须存在<br>操作结果:返回线性表L中的数据元素个数</li>
</ul>
<h5 id="基本操作-三"><a href="#基本操作-三" class="headerlink" title="基本操作(三)"></a>基本操作(三)</h5><ul>
<li>GetElem(L,i,&amp;e)<br>初始条件:线性表L必须存在 ,1&lt;=i&lt;=ListLength(L)<br>操作结果:用e返回线性表L中第i个数据元素的值</li>
<li>LiocateElem(L,e,compare())<br>初始条件:线性表L必须存在 ,compare()是数据元素判定元素<br>操作结果:返回线性表L中第一个与e满足compare()的数据元素的位序,若不存在返回0</li>
</ul>
<h5 id="基本操作-四"><a href="#基本操作-四" class="headerlink" title="基本操作(四)"></a>基本操作(四)</h5><ul>
<li>PriorElem(L,cur_e,&amp;pre_e)<br>初始条件:线性表L必须存在<br>操作结果:若cur_e是L的数据元素,且不是第一个,则用pre_e返回它的前驱,否则操作失败;pre_e无意义</li>
<li>NextElem(L,cur_e,&amp;next_e)<br>初始条件:线性表L必须存在<br>操作结果:若cur_e是L的数据元素,且不是最后一个,则用next_e返回它的前驱,否则操作失败;next_e无意义</li>
</ul>
<h5 id="基本操作-五"><a href="#基本操作-五" class="headerlink" title="基本操作(五)"></a>基本操作(五)</h5><ul>
<li>ListInsert(&amp;L,i,e)<br>初始条件:线性表L必须存在,1&lt;=i&lt;=ListLength(L)+1<br>操作结果:在L的第i个位置之前插入新的数据元素e,L的长度加一</li>
</ul>
<h5 id="基本操作-六"><a href="#基本操作-六" class="headerlink" title="基本操作(六)"></a>基本操作(六)</h5><ul>
<li>ListDelete(&amp;L,i,&amp;e)<br>初始条件:线性表L必须存在,1&lt;=i&lt;=ListLength(L)<br>操作结果:删除L的第i个数据元素,并用e返回其值,L的长度减一</li>
<li>ListTraverse(&amp;L,visited())<br>初始条件:线性表L必须存在<br>操作结果:遍历,依次对线性表中每个元素调用visited()</li>
</ul>
<h3 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a>线性表的顺序表示和实现</h3><p>线性表的顺序表示又称为<strong>顺序存储结构</strong>或<strong>顺序映像</strong>.<br><strong>顺序存储定义</strong>:把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构.<br>线性表的第一个数据元素的存储位置称为<strong>起始位置</strong>或<strong>基地址</strong>.<br>依次存储,地址连续,中间没有空的存储单元.</p>
<table>
<thead>
<tr>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>是一个典型的<strong>线性表顺序存储结构</strong>.</p>
<p>若地址不连续,中间存在空的存储单元.</p>
<table>
<thead>
<tr>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center"></th>
<th align="center"></th>
<th align="center">6</th>
<th align="center">7</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>这就不是一个<strong>线性表顺序存储结构</strong>.<br>所以说,顺序表顺序存储结构必须占用一片连续的存储空间,只要知道某个元素的存储位置就可以知道其他元素的存储位置.<br>假设线性表的每个元素需要L个存储单元,则第i+1个数据元素的存储位置和第i个数据元素的存储位置之间的关系满足:<br>LOC（ai+1）=LOC（ai）+L<br>由此，所有数据元素的存储位置均可由第一个数据元素的存储位置得到:<br>LOC(ai)=LOC(ai)+(i-1)*L</p>
<p>我们可以发现，顺序表的存储方式与数组类似,所以,我们可以用一维数组表示顺序表,但是我们的数组不能动态分配.所以我们用一个变量表示顺序表的长度属性.<br>所以我们可以这样定义:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INIT_SIZE 100  <span class="comment">//线性表存储空间的初始分配量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	ElemType elem[LIST_INIT_SIZE]; <span class="comment">//静态分配数组</span></span><br><span class="line">	<span class="keyword">int</span> length;<span class="comment">//当前长度</span></span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INIT_SIZE 100  <span class="comment">//线性表存储空间的初始分配量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	ElemType *elem;<span class="comment">//动态分配数组</span></span><br><span class="line">	<span class="keyword">int</span> length;<span class="comment">//当前长度</span></span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态分配</span></span><br><span class="line">SqList L;</span><br><span class="line">L.elem=(ElemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType)*LIST_INIT_SIZE);</span><br></pre></td></tr></table></figure>

<p>ELemType是你需要用到的数据类型,根据问题进行修改,或者定义.</p>
<h5 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a><strong>线性表的基本操作</strong></h5><p>操作算法中用到的预定义常量和类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数结果状态代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFEASIBLE -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Status 是函数的类型。其值是函数结果状态代码</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br></pre></td></tr></table></figure>

<ul>
<li>线性表L的初始化(参数用引用)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitList_Sq</span><span class="params">(SqList &amp;L)</span></span>&#123; 			<span class="comment">//构造一个空的顺序表L</span></span><br><span class="line">	L.elem=<span class="keyword">new</span> ElemType[MAXSIZE];		<span class="comment">//为顺序表分配空间</span></span><br><span class="line">	<span class="keyword">if</span>(!L.elem)<span class="built_in">exit</span>(OVERFLOW);			<span class="comment">//存储分配失败</span></span><br><span class="line">	L.length=<span class="number">0</span>;							<span class="comment">//空表长度为0</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>销毁线性表</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L.elem)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>(L.elem);<span class="comment">//释放存储空间</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>清空线性表</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">	L.length=<span class="number">0</span>; <span class="comment">//将线性表的长度置为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>求线性表的长度</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLength</span><span class="params">(SqList L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> L.length; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>判断线性表L是否为空</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(SqList L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>顺序表的取值(根据位置i获取相应位置数据元素的内容)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetElem</span><span class="params">(SqList L,<span class="keyword">int</span> i,ElemType &amp;e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length)   <span class="comment">//判断i值是否合理，若不合理，返回ERROR</span></span><br><span class="line">	retrun ERROR;</span><br><span class="line">	<span class="keyword">else</span> e = L.length[i<span class="number">-1</span>]; <span class="comment">//将i-1存储单元的数据给e</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>顺序表的查找(按值查找,在L中与指定值e相同的数据元素的位置)<br>从表的一端,逐个进行记录的关键字和给定值比较,找到返回元素位置序号,未找到,返回0.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(SqList L,ElemType e)</span></span>&#123;</span><br><span class="line">	<span class="comment">//在线性表L中查找值为ｅ的数据元素，返回其序号（是第几个元素）</span></span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(L.elem[i]==e)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> i+<span class="number">1</span>;  <span class="comment">//查找成功，返回序号</span></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//查找失败，返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里引出一个概念，<strong>平均查找长度ASL(Average Search Length):</strong><br>-为确定记录在表中的位置,需要与给定值进行比较的关键字的个数的期望值叫做查找算法的<strong>平均查找长度.</strong></p>
<p><strong><em>ASL=∑Pi(找到第i给个记录需要比较的次数) \</em> Ci(第i个记录被查找的概率);*</strong></p>
<p>所以，顺序查找的平均查找长度是：ASL=P1+2P2+…+(n-1)Pn-1+nPn<br>假设每个记录的查找概率相等：Pi=1/n<br>则：ASL=（1/n)([n(n+1)]/2)=<strong>(n+1)/2</strong></p>
<ul>
<li>插入算法:线性表的插入运算是指在第i(1&lt;=i&lt;=n+1)个位置上,插入一个新结点e,使长度为n的线性表(a1,…ai-1,ai…an)变成长度为n+1的线性表(a1,…ai-1,e,ai…an)</li>
</ul>
<p>算法思想:</p>
<ol>
<li>判断插入位置i是否合法.</li>
<li>判断顺序表的存储空间是否已满,若满了返回ERROR.</li>
<li>将第n到i位的元素依次向后移动一个位置,空出第i个位置.</li>
<li>将要插入的新元素e放入第i个位置.</li>
<li>将表长度+1,插入成功返回OK.</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert_Sq</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> i,ElemType e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>)<span class="keyword">return</span> ERROR; <span class="comment">//i值不合法</span></span><br><span class="line">	<span class="keyword">if</span>(L.length==MAX_SIZE)<span class="keyword">return</span> ERROR;  <span class="comment">//当前存储空间已满	</span></span><br><span class="line">	<span class="keyword">for</span>(j=L.length<span class="number">-1</span>;j&gt;=i<span class="number">-1</span>;j--)</span><br><span class="line">	&#123;</span><br><span class="line">    	L.elem[j+<span class="number">1</span>]=L.elem[j];	<span class="comment">//将i-1之后所有元素后移</span></span><br><span class="line">    &#125;</span><br><span class="line">    L.elem[i<span class="number">-1</span>]=e;			<span class="comment">//将新元素e放入第i个位置</span></span><br><span class="line">    L.length++;				<span class="comment">//表长+1；</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ASL=1/(n+1)<em>0+1/(n+1)</em>1+1/(n+1)<em>2+…+1/(n+1)</em>n = n/2.</p>
<p>*删除算法：线性表的删除运算是指将表的第i(1&lt;=i&lt;=n)个节点删除，使长度为n的线性表(a1,…,ai-1,ai,…,an)变为长度为n-1的线性表(a1…,ai-1,ai+1,…an)</p>
<p>算法思想:</p>
<ol>
<li>判断删除位置i是否合法.</li>
<li>将预删除的元素保留在e中.</li>
<li>将第i+i至n位的元素依次向前移动一个位置.</li>
<li>表长-1,删除成功返回OK.</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete_Sq</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length) <span class="keyword">return</span> ERROR; <span class="comment">//i不合法</span></span><br><span class="line">	<span class="keyword">for</span>(j=i;j&lt;L.length;j++)</span><br><span class="line">	&#123;</span><br><span class="line"> 		L.elem[j]=L.elem[j+<span class="number">1</span>]; <span class="comment">//被删除元素之后的元素前移一位</span></span><br><span class="line"> 	&#125;</span><br><span class="line"> 	L.length--;					<span class="comment">//表长-1</span></span><br><span class="line"> 	<span class="keyword">return</span> OK;</span><br><span class="line"> 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ASL=1<em>(n-1)+2</em>(n-2)+…+n*0 = (n-1)/2</p>
<p><strong>小结:</strong> 顺序表的特点</p>
<ol>
<li>利用数据元素的存储位置表示线性表中相邻数据元素的前后关系,既线性表的逻辑结构与存储结构一致</li>
<li>在访问线性表时,可以快速的计算出任何一个数据元素的存储地址.因此可以粗略的认为,访问每个元素所花的时间相等</li>
<li>这种存取元素的方法称为<strong>随机存取法</strong></li>
</ol>
<p>顺序表的操作算法分析:</p>
<ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(1)</li>
</ul>
<p>顺序表的优缺点:</p>
<ul>
<li>优点</li>
</ul>
<ol>
<li>存储密度大(节点本身所占存储量/结点结构所占存储量)</li>
<li>可以随机存取表中任意元素</li>
</ol>
<ul>
<li>缺点</li>
</ul>
<ol>
<li>在插入、删除运算中,需要移动大量元素</li>
<li>浪费存储空间</li>
<li>输入静态存储形式,数据元素的个数不能自由扩充</li>
</ol>
<h3 id="线性表的链式表示和实现"><a href="#线性表的链式表示和实现" class="headerlink" title="线性表的链式表示和实现"></a>线性表的链式表示和实现</h3><ul>
<li><p>链式存储结构:</p>
<p>用一组物理位置任意的存储单元来存放线性表的数据元素.<br>链表中元素的物理位置和逻辑位置不一定相同.<br>-与链式存储有关的术语</p>
<ol>
<li><strong>结点</strong>:数据元素的存储映像.由数据域和指针域两部分组成</li>
<li><strong>链表</strong>:n个结点由指针链组成一个链表</li>
<li><strong>单链表、双链表、循环链表</strong>：<br>结点只有一个指针域的链表,称为<strong>单链表</strong>(存后继)<br>每一个结点有两个指针域,称为<strong>双链表</strong>(第一个指针域存前驱，后一个指针域存后继)<br>首尾相接的链表称为<strong>循环链表</strong></li>
<li><strong>头指针、头结点和首元结点</strong>：<br><strong>头指针(head)</strong>:是指向链表中第一个结点的指针<br><strong>首元结点</strong>:是指链表中存储第一个数据元素a1的结点<br><strong>头结点</strong>:是在链表的首元结点之前附设的一个结点</li>
</ol>
<ul>
<li><p>所以链表的存储结构有两种形式:</p>
<ol>
<li><p>不带头结点</p>
<p><img src="/2020/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%B8%89-%E7%BA%BF%E6%80%A7%E8%A1%A8/1.png" alt></p>
</li>
<li><p>带头结点</p>
<p><img src="/2020/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%B8%89-%E7%BA%BF%E6%80%A7%E8%A1%A8/2.png" alt></p>
<ul>
<li><p><strong>带头结点的单链表</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span>&#123;</span> <span class="comment">//声明结点类型和指向节点的指针类型</span></span><br><span class="line">	ElemType data;			<span class="comment">//结点的数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span>* <span class="title">next</span>;</span>		<span class="comment">//结点的指针域</span></span><br><span class="line">&#125;Lnode,*LinkList; 			</span><br><span class="line"><span class="comment">//LinkList为指向结构体Lnode的指针类型</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>单链表的初始化，即构造一个空表。<br>步骤：1.生成新结点作为头结点，用头指针L指向头结点。2.将头结点的指针域置空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitList_L</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">       	L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">       	<span class="keyword">return</span> OK;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断链表是否为空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">IsEmpty</span><span class="params">(LinkList L)</span></span>&#123;<span class="comment">//若L为空，返回1，否则返回0</span></span><br><span class="line">       	<span class="keyword">if</span>(L-&gt;next==<span class="number">1</span>)&#123;<span class="comment">//非空</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单链表的销毁:链表销毁后不存在<br>从头指针开始,依次释放所有结点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">       <span class="function">Status <span class="title">DestroyList_L</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">	Lnode* p;</span><br><span class="line">       	<span class="keyword">while</span>(L)&#123;</span><br><span class="line">	p=L;</span><br><span class="line">       	L=L-&gt;next;</span><br><span class="line">       	<span class="built_in">free</span>(P);</span><br><span class="line">&#125;</span><br><span class="line">       	<span class="keyword">return</span> OK;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>清空单链表:链表仍存在,但链表中无元素,成为空链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">       <span class="function">Status <span class="title">DestroyList_L</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">       	Lnode* p;</span><br><span class="line">       	<span class="keyword">while</span>(L)&#123;</span><br><span class="line">       	p=L;</span><br><span class="line">	L=L-&gt;next;</span><br><span class="line">       	<span class="built_in">free</span>(P);</span><br><span class="line">&#125;</span><br><span class="line">       	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>清空单链表:链表仍存在,但链表中无元素,成为空链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">       <span class="function">Status <span class="title">ClearList_L</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">       	Lnode* p;</span><br><span class="line">       	Lnode* q;</span><br><span class="line">       	p=L-&gt;next;</span><br><span class="line">       	<span class="keyword">while</span>(p)&#123;</span><br><span class="line">       		q=p-&gt;next;</span><br><span class="line">       		<span class="built_in">free</span>(p);</span><br><span class="line">       		p=q;</span><br><span class="line">       	&#125;</span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;   <span class="comment">//头结点指针域为空</span></span><br><span class="line">       	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求单链表长</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">ListLength_l</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">       	Lnode*p;</span><br><span class="line">       	<span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">       	p=L-&gt;next;</span><br><span class="line">       	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">       		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       		<span class="keyword">while</span>(p)&#123;</span><br><span class="line">       			count++;</span><br><span class="line">       			p=p-&gt;next;</span><br><span class="line">       		&#125;</span><br><span class="line">       	&#125;</span><br><span class="line">       	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>读取第i个元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">List</span><span class="params">(LinkList L,<span class="keyword">int</span> i，ElemType &amp;e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">	Lnode* p;</span><br><span class="line">	p=L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p&amp;&amp;i&lt;j)&#123;<span class="comment">//向后扫描，直到p指向第i个元素，或p为空</span></span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!p||j&gt;i)<span class="keyword">return</span> ERROR;<span class="comment">//第i个元素不存在</span></span><br><span class="line">	e=p-&gt;data;		<span class="comment">//	取第i个元素</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单链表的按值查找——根据指定数据获取该数据所在的位置(地址)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回地址</span></span><br><span class="line">       <span class="function">Lnode *<span class="title">LocateElem_L</span><span class="params">(LinkList L,ElemType e)</span></span>&#123;</span><br><span class="line">       	LinkList p;</span><br><span class="line">       	p=L-&gt;next;</span><br><span class="line">       	<span class="keyword">while</span>(P&amp;&amp;p-&gt;data!=e)&#123;</span><br><span class="line">       		p=p-&gt;next;</span><br><span class="line">       	&#125;</span><br><span class="line">       	<span class="keyword">return</span> p;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//返回序号</span></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">LocateElem_L</span><span class="params">(LinkList L,ElemType e)</span></span>&#123;</span><br><span class="line">       	LinkList p;</span><br><span class="line">       	p=L-&gt;next;</span><br><span class="line">       	j=<span class="number">1</span>;</span><br><span class="line">       	<span class="keyword">while</span>(p&amp;&amp;p-&gt;data!=e)&#123;</span><br><span class="line">       		p=p-&gt;next;</span><br><span class="line">       		j++;</span><br><span class="line">       	&#125;</span><br><span class="line">       	<span class="keyword">if</span>(p) <span class="keyword">return</span> j;</span><br><span class="line">       	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入——在第i个结点前插入值为e的新节点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">ListInsert_L</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> i，ElemType e)</span></span>&#123;</span><br><span class="line">       	Lnode* p,s;</span><br><span class="line">	p=L;</span><br><span class="line">       	<span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">       	<span class="keyword">while</span>(p&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">       		p=p-&gt;next;</span><br><span class="line">       		j++;</span><br><span class="line">       	&#125;<span class="comment">// 寻找第i-1个结点，p指向i-1结点</span></span><br><span class="line">       	<span class="keyword">if</span>(!p||j&gt;i<span class="number">-1</span>)<span class="keyword">return</span> ERROR;<span class="comment">//i大于表长或小于一，插入位置非法</span></span><br><span class="line">       	s=(Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Lnode));</span><br><span class="line">       	s.data=e;</span><br><span class="line">       	s-&gt;next=p-&gt;next;</span><br><span class="line">       	p-&gt;next=s;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除结点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete_L</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> i,ElemType &amp;e)</span></span>&#123;</span><br><span class="line">       	Lnode* p,q;</span><br><span class="line">	p=L;</span><br><span class="line">       	<span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p-&gt;next&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">       		p=p-&gt;next;</span><br><span class="line">       		j++;</span><br><span class="line">       	&#125;<span class="comment">//寻找第i个结点，并令p指向其前驱</span></span><br><span class="line">       	<span class="keyword">if</span>(!(p-&gt;next)||j&gt;i<span class="number">-1</span>)<span class="keyword">return</span> ERROR;<span class="comment">//删除位置不合理</span></span><br><span class="line">       	q=p-&gt;next;<span class="comment">//q指向要删除的结点</span></span><br><span class="line">       	p-&gt;next=q-&gt;next;<span class="comment">//p指向删除之后的结点</span></span><br><span class="line">       	e=q-&gt;data;<span class="comment">//将删除的元素保存在e中</span></span><br><span class="line">       	<span class="built_in">free</span>(q);<span class="comment">//释放要删除的结点</span></span><br><span class="line">       	<span class="keyword">return</span> OK;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>头插法建立单链表:元素插入在链表头部,所以也叫前插法</p>
<ol>
<li>从一个空表开始,重复读入数据</li>
<li>生成新结点,将读入数据存放到新结点的数据域中</li>
<li>从最后一个结点开始,依次将各结点插入到链表的前端</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateList_L</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">      	L=(LinkList)<span class="built_in">malloc</span>(siziof(Lnode));</span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>;<span class="comment">//建立一个带头结点的单链表</span></span><br><span class="line">      	<span class="keyword">for</span>(i=n;i&lt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">      		p=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Lnode));<span class="comment">//生成新结点p</span></span><br><span class="line">      		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p-&gt;data);<span class="comment">//输入元素值</span></span><br><span class="line">	p-&gt;next=L-&gt;next;<span class="comment">//插入到表头</span></span><br><span class="line">      		L-&gt;next=p;</span><br><span class="line">      	&#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>尾插法建立单链表–元素插入到链表尾部,也叫后插法</p>
<ol>
<li>从一个空表L开始,将新结点逐个插入到链表的尾部,尾指针r指向链表的尾结点</li>
<li>初始时,r和L均指向头结点.每读入一个数据元素则申请一个新结点,将新结点插入到尾结点后,r指向新结点</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">CreatList_R</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">L=(LinkList)<span class="built_in">malloc</span>(siziof(Lnode));</span><br><span class="line">      	L-&gt;next=<span class="literal">NULL</span>;<span class="comment">//建立一个带头结点的单链表</span></span><br><span class="line">r=L; <span class="comment">//尾指针r指向头结点;</span></span><br><span class="line">      	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">	p=LinkList)<span class="built_in">malloc</span>(siziof(Lnode));</span><br><span class="line">      		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p-&gt;data);<span class="comment">//生成新结点，输入元素值</span></span><br><span class="line">      		p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	r-&gt;next=p;<span class="comment">//插入到表尾</span></span><br><span class="line">      		r=p;<span class="comment">//让r指向新的尾结点</span></span><br><span class="line">      	&#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p><strong>循环链表</strong>:是一种头尾相接的链表(即:表中最后一个结点的指针域指向头结点,整个链表形成一个环)</p>
<ul>
<li>优点:从表中任一结点出发均可找到表中其他结点</li>
<li>注意:由于循环链表中没有NULL指针,所以遍历操作时,其终止条件就不像非循环链表那样判断p或p-&gt;next是否为空,而是判断他们是否等于头指针.<br>表的操作常常是在表的首尾进行,所以可以使用尾指针表示单循环链表,a1的存储位置是:r-&gt;next-&gt;next;an的存储位置是r;</li>
</ul>
<p>如何将两个带尾指针的循环列表合并</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList  <span class="title">Connect</span><span class="params">(LinkList Ta,LinkList Tb)</span></span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">	p=Ta-&gt;next;	<span class="comment">//p存表头结点</span></span><br><span class="line">       	Ta-&gt;next=Tb-&gt;next-&gt;next;<span class="comment">//Tb表头链接Ta表尾</span></span><br><span class="line">       	<span class="built_in">free</span>(Tb-&gt;next);<span class="comment">//释放Tb的表头结点</span></span><br><span class="line">       	Tb-&gt;next=p;<span class="comment">//修改指针</span></span><br><span class="line">	<span class="keyword">return</span> Tb;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>  <strong>双向链表</strong></p>
<table>
<thead>
<tr>
<th align="center">prior</th>
<th align="center">data</th>
<th align="center">next</th>
</tr>
</thead>
<tbody><tr>
<td align="center">指向前驱结点</td>
<td align="center">数据元素</td>
<td align="center">指向后继结点</td>
</tr>
</tbody></table>
<p>  双向链表的结构可定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	struc DuLNode *prior,*next;</span><br><span class="line">&#125;DuLNode,*DuLinkList;</span><br></pre></td></tr></table></figure>

<p>和单链的循环链表类似，双向链表也可以有循环表</p>
<ul>
<li>让头结点的前驱指针指向链表的最后一个结点</li>
<li>让最后一个结点的后继指向头结点</li>
</ul>
<p><strong>双向链表的插入操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListInsert_DuL</span><span class="params">(DuLinkList &amp;L,<span class="keyword">int</span> i,ElemType e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!p=GetElemP_DuL(L,i))<span class="keyword">return</span> ERROR;</span><br><span class="line">	s=(DuLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DuLNode));</span><br><span class="line">	s-&gt;data=e;</span><br><span class="line">	s-prior=p-&gt;prior;</span><br><span class="line">	p-&gt;piror-&gt;next=s;</span><br><span class="line">	s-&gt;next=p;</span><br><span class="line">	p-&gt;prior=s;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>双向链表的删除操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListDelete_DuL</span><span class="params">(DuLink &amp;L,<span class="keyword">int</span> i,ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!p=GetElem_DuL(L,i)) <span class="keyword">return</span> ERROR;</span><br><span class="line">	e=p-&gt;data;</span><br><span class="line">	p-&gt;prior-&gt;next=p-&gt;next;</span><br><span class="line">	p-&gt;next-&gt;prior=p-&gt;prior;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h3><ul>
<li><p>链式存储结构的优点:</p>
<ul>
<li>结点空间可以<strong>动态申请和释放</strong></li>
<li>数据元素的逻辑次序靠<strong>结点的指针</strong>来指示，插入和删除时<strong>不需要移动数据元素</strong></li>
</ul>
</li>
<li><p>链式存储结构的缺点</p>
<ul>
<li><p><strong>存储密度</strong>比较小，每个结点的指针域需<strong>额外占用存储空间</strong>，当每个结点的数据域所占字节不多时，指针域所占存储空间的比重显得很大</p>
<p><img src="/2020/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%B8%89-%E7%BA%BF%E6%80%A7%E8%A1%A8/3.png" alt></p>
</li>
<li><p>链式存储结构是一种非随机存取的结构，对于任一结点的操作都需要从头指针依指针链查找到该结点，增加了算法的复杂度</p>
</li>
</ul>
</li>
</ul>
<p>在这里插入图片描述</p>
<p><img src="/2020/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%B8%89-%E7%BA%BF%E6%80%A7%E8%A1%A8/4.png" alt></p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>33</span>
                    </p>
                
                
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/DataStructure/"># DataStructure</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9B%9B-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/">数据结构与算法(四):栈和队列</a>
            
            
            <a class="next" rel="next" href="/2020/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%8C-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/">数据结构与算法(二):时间复杂度和空间复杂度</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 33 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
